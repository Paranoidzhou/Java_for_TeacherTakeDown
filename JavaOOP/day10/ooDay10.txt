Shoot射击游戏第一天:
1.创建6个对象类，并创建World类测试

Shoot射击游戏第二天:
1.创建了6个对象类的构造方法，在World类中测试

Shoot射击游戏第三天:
1.设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
2.设计FlyingObject超类，6个对象类继承超类
3.给FlyingObject超类设计了两个构造方法，6个派生类中分别调用

Shoot射击游戏第四天:
1.将小敌机数组、大敌机数组、小蜜蜂数组合为FlyingObject数组
2.在6个派生类中重写step()
3.画窗口

Shoot射击游戏第五天:
1.将类中的成员添加访问控制修饰符
2.设置图片属性

Shoot射击游戏第六天:
1.画对象:
  1)想画对象，得先去获取对象的图片，
    每个对象都得获取图片，意味着获取图片行为为共有的行为，
	  所以需要将获取图片的行为设计在FlyingObject超类中，
    每个对象获取图片的行为都是不一样的，
      所以获取图片的行为设计为抽象方法
	--------在FlyingObject类中设计抽象方法getImage()
  2)在获取对象的图片时，需要去考虑对象的状态(生命周期)，
    状态分三种(活着的、死了的(未删除)、删除的)，
	在实际应用中，状态都应设计为常量，
	每个对象都有状态，所以将状态设计在FlyingObject超类中，
	--------在FlyingObject类中设计三个常量和变量(存储当前状态)
    在获取图片时，需要去判断每个对象的状态，用于获取不同的图片，
	所以对象状态判断的行为为共有的行为，设计在FlyingObject超类中，
	每个对象判断状态的行为都是一样的，设计为普通方法
	--------在FlyingObject类中设计isLife()/isDead()/isRemove()
  3)在派生类中重写getImage()用于在不同状态下获取不同的图片
    3.1)Sky天空，直接返回image
	3.2)Bullet子弹:
	    3.2.1)若活着的，直接返回image
		3.2.2)若死了的，就删除
    3.3)Airplane小敌机:
        3.3.1)若活着呢，返回第1张图片
        3.3.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
    3.4)Airplane小敌机:
        3.4.1)若活着呢，返回第1张图片
        3.4.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
	3.5)Airplane小敌机:
        3.5.1)若活着呢，返回第1张图片
        3.5.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
    3.6)Hero英雄机:
	    3.6.1)若活着呢，返回2张图片的切换
  4)图片有了，就可以开画了，6个对象都可开画，属于共有的行为，
      所以将画的行为设计在FlyingObject超类中，
	所有对象画的行为都是一样的，所以设计为普通方法
	--------在FlyingObject超类中设计普通方法paintObject()画对象
  5)因为Sky天空是两张图，所以需要重写超类的paintObject()
    --------在Sky类中重写paintObject()
  6)画的行为完以后，只需要在窗口上调用即可
    --------在World类中重写paint()，而后调用paintObject()

Shoot射击游戏第七天:
1.敌人入场:
  1)敌人是由窗口产生的，所以在World中设计nextOne()生成敌人对象
  2)敌人入场为定时发生的，在run()中调用enterAction()实现敌人入场
    在enterAction()中:
	  每400毫秒调用nextOne()获取敌人，enemies扩容，装在最后一个元素上
2.子弹入场:
  1)子弹是由英雄机发射出来的，所以在Hero中设计shoot()生成子弹对象
  2)子弹入场为定时发生的，在run()中调用shootAction()实现子弹入场
    在shootAction()中:
	  每300毫秒调用hero的shoot()获取子弹，bullets扩容，数组追加
3.飞行物移动:
  1)移动是所有对象所共有的行为，并且每个对象移动的形为都是不一样的，
    所以在超类FlyingObject中设计了抽象方法step()，派生类重写step()
  2)飞行物移动为定时发生的，在run()中调用stepAction()实现飞行物移动
    在stepAction()中:
	  天空动，遍历敌人而后敌人动，遍历子弹而后子弹动

Shoot射击游戏第八天:
1.英雄机随着鼠标移动:
  1)英雄机移动是英雄机的行为，所以在Hero中设计moveTo(x,y)实现英雄机随着鼠标移动
  2)英雄机随着鼠标移动是事件触发的，在侦听器中重写mouseMoved()鼠标移动事件
    在mouseMoved()中:
	  获取鼠标的x和y坐标，而后英雄机随着动
2.删除越界的飞行物:
  1)越界检查为所有飞行物都具备的行为，只是每个对象的具体行为不一样，
    在超类FlyingObject中设计抽象方法outOfBounds()，6个派生类中分别重写
  2)删除越界飞行物为定时发生的，所以在run()中调用outOfBoundsAction()
    在outOfBoundsAction()中:
	  声明不越界敌人/子弹数组，遍历enemies/bullets，获取每个敌人或子弹
	  判断若不越界，则将对象添加到不越界敌人/子弹数组中，
	  将不越界敌人/子弹数组复制到enemies/bullets中
3.设计Enemy得分接口，而后Airplane和BigAirplane实现接口
  设计Award奖励接口，而后Bee实现接口

Shoot射击游戏第九天:
1.子弹与敌人的碰撞:
  1)在超类FlyingObject中设计hit()实现敌人与子弹/英雄机的碰撞
    在超类FlyingObject中设计goDead()实现飞行物去死
	在Hero类中设计addLife()增命、addDoubleFire()增火力
  2)子弹与敌人的碰撞为定时发生的，所以在run()中调用bulletBangAction()实现子弹与敌人的碰撞
    在bulletBangAction()中:
	  遍历所有子弹，获取每个子弹，遍历所有敌人，获取每个敌人，
	  判断是否撞上了，若撞上了则:
	    2.1)子弹去死、敌人去死
		2.2)若撞了小敌机和大敌机，则玩家得分
		    若撞了小蜜蜂，则英雄机得奖励
2.画分和画命:
  1)在Hero类中设计getLife()获取命
  2)在paint()方法中，画分和画命

Shoot射击游戏第九天:
1.英雄机与敌人的碰撞:
  1)借用FlyingObject中的hit()碰撞行为
    借用FlyingObject中的goDead()去死行为
	在Hero中设计subtractLife()减命、clearDoubleFire()清空火力值
  2)因为英雄机与敌人碰撞为定时发生的，所以在run()中调用heroBangAction()实现碰撞
    在heroBangAction()中:
	  遍历所有敌人，获取每个敌人，判断是否与英雄机撞上了，
      若撞上了: 敌人去死、英雄机减命、英雄机清空火力值
2.检测游戏结束:
  1)借用Hero的getLife()获取命
  2)因为检测游戏结束为定时发生的，所以在run()中调用checkGameOver()实现检测结束
    在checkGameOverAction()中:
	  判断英雄机的命数是否<=0，若为true则...
3.画状态:
  1)设计了四个状态常量，当前状态state变量
    设计了三个静态图片，在static块中初始化
  2)在paint()中设计在不同状态下画不同的图片
  3)将一堆action()设计为仅在运行状态下执行
    将英雄机随着鼠标动设计为仅在运行状态下执行
  4)重写mouseClicked()鼠标点击事件
    重写mouseExited()鼠标点击事件
	重写mouseEntered()鼠标点击事件


回顾:
1.多态:
  1)意义:行为的多态、对象的多态
  2)向上造型: 超类+所实现的接口
  3)强转成功的条件:
    3.1)引用所指向的对象就是该类型
	3.2)引用所指向的对象实现了该接口/继承了该类
  4)若不符合如上两个条件，则发生ClassCastException类型转换异常
    建议在强转之前先instanceof来判断


正课:
1.内存管理:由JVM来管理
  1)堆:
    1.1)存储new出来的对象(包括实例变量)
	1.2)垃圾:没有任何引用所指向的对象，
	    垃圾回收器(GC)不定时到内存中清扫垃圾，
        回收过程是透明的(看不到的)，不一定一发现垃圾就立刻回收，
		调用System.gc()可以建议虚拟机尽快调度GC来回收垃圾
	1.3)实例变量的生命周期:
	      创建对象时存在堆中，对象被回收时一并被回收
	1.4)内存泄漏:不再使用的对象还没有被及时的回收
	    建议:不再使用的对象及时将引用设置为null
  2)栈:
    2.1)正在调用的方法中的局部变量(包括方法的参数)
	2.2)调用方法时，在栈中为该方法分配一块对应的栈帧，
	    栈帧中存储方法中的局部变量(包括方法的参数)，
		方法调用结束时，栈帧被清除，局部变量一并被清除
	2.3)局部变量的生命周期:
	      方法调用时存储在栈中，方法结束时与栈帧一并被清除
  3)方法区:
    3.1)存储.class字节码文件(包括方法、静态变量)
	3.2)方法只有一份，通过this来区分具体的访问对象

设计规则:
1)将所有派生类所共有的属性和行为，抽到超类中-------抽共性
2)所有派生类的行为都一样，设计为普通方法
  所有派生类的行为都不一样，设计为抽象方法
3)将部分派生类所共有的行为，抽到接口中
  符合既是也是原则时，使用接口
  接口是对继承的单根性的扩展------------多继承


面向对象三大特征:
1.封装:
  1)类:封装的是对象的属性的行为
  2)方法:封装一段特定的业务逻辑功能
  3)访问控制修饰符:封装的是具体的访问权限
2.继承:
  1)作用:代码复用
  2)超类:所有派生类所共有的属性和行为
    接口:部分派生类所共有的行为
	派生类:派生类所特有的属性和行为
  3)单一继承、多接口实现，传递性
3.多态:
  1)行为多态(所有抽象方法都是多态的)
    对象多态(所有对象都是多态的)
  2)向上造型、强制类型转换、instanceof
  3)多态的表现形式:
    3.1)重写:根据对象的不同来多态
	3.2)重载:根据参数的不同来多态


面向对象课程安排:
第一天:
  1.知识点:
    1)什么是类？什么是对象？
	2)如何创建类？如何创建对象？如何访问成员？
  2.项目:
    1)创建6个对象类，并创建World类测试
第二天:
  1.知识点:
    1)方法的重载
	2)构造方法
	3)this
	4)null和NullPointerException
	5)引用类型之间画等号
  2.项目:
    1)给6个对象类添加构造方法，并测试
第三天:
  1.知识点:
    1)引用类型数组
	2)继承
	3)super
  2.项目:
    1)设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
	2)设计超类FlyingObject，6个对象类分别继承，并测试
	3)给FlyingObject设计两个构造方法，6个对象类分别调用超类的构造方法
第四天:
  1.知识点:
    1)向上造型
	2)重写、重写与重载的区别
  2.项目:
    1)将小敌机、大敌机、小蜜蜂数组合为FlyingObject数组
	2)重写超类FlyingObject的step()方法
	3)画窗口
第五天:
  1.知识点:
    1)package和import
	2)访问控制修饰符
	3)final,static,static final
  2.项目:
    1)将类中的所有成员添加访问控制修饰符
	2)给6个对象类添加图片属性
	3)设计窗口的宽和高为常量，适当地方做修改
第六天:
  1.知识点:
    1)抽象方法
	2)抽象类
  2.项目:
    1)画对象
第七天:
  1.知识点:
    1)成员内部类
	2)匿名内部类
  2.项目:
    1)敌人入场
	2)子弹入场
	3)飞行物移动
第八天:
  1.知识点:
    1)接口
  2.项目:
    1)英雄机随着鼠标移动
	2)删除越界的飞行物
	3)设计Enemy和Award接口，小敌机、大敌机、小蜜蜂分别实现接口
第九天:
  1.知识点:
    1)多态:意义、向上造型、强制类型转换、instanceof
  2.项目:
    1)子弹与敌人的碰撞
	2)画分和画命
第十天:
  1.知识点:
    1)内存管理:堆、栈、方法区
  2.项目:
    1)英雄机与敌人的碰撞
	2)检测游戏结束
	3)画状态


1.何时用:当程序的运行结果与你的预期不同时，需要调试
2.调试方式:
  1)打桩: System.out.println(数据);
  2)Debug调试工具:
    2.0)添加断点
    2.1)四个键:
	    2.1.1)F5:单步调试(会进入到方法中)
		2.1.2)F6:逐过程调试(不会进入到方法中)
		2.1.3)F7:结束方法的调试(从方法中返回)
		2.1.4)F8:直接跳到下一个断点(若后面无断点则结束调试)
	2.2)会看两个东西:
	    2.2.1)会看变量
		2.2.2)添加监视



























若撞上了:
1)敌人去死
2)英雄机减命、英雄机清空火力值



hero.getLife()<=0



















现在的是-------只要不越界就要



要的是:
A:不越界，并且，LIFE的
B:不越界，并且，LIFE的或DEAD的(不是REMOVE的)

















class Airplane{
  int width;
  int height;
  int x;
  int y;
}






Airplane a1 = new Airplane();
a1.width =;
a1.height=;
a1.x=;
a1.y=;

Airplane a2 = new Airplane();
a2.width =;
a2.height=;
a2.x=;
a2.y=;












class Aoo{
  void show(){}
}
class Boo extends Aoo{
  void show(String name){} //方法的重载
}













System.out.println();
System.out.println(25);
System.out.println(35.6);
System.out.println('你');
System.out.println(true);
System.out.println("Hello");


















Aoo    o = new Aoo();
Object oo = new Aoo();












Object

class FlyingObject extends Object{
}
class Airplane extends FlyingObject{
}















Airplane a = new Airplane();




















实例变量:
1)类中，方法外
2)创建对象时存在堆中，对象被回收时一并被回收
3)有默认值
局部变量:
1)方法中
2)方法调用时存储在栈中，方法结束时与栈帧一并被清除
3)没有默认值











Aoo o = new Aoo();-------------------a=0
o.show(5);---------------------------b=5

class Aoo{
  int a;
  void show(int b){
    int c;
	System.out.println(a); //0
	System.out.println(b); //5
	System.out.println(c); //编译错误
  }
}




















项目功能:
1.英雄机与敌人的碰撞
2.画状态

Debug调试:











